---
title: AEAD有哪些安全陷阱？
date: 2022-03-09 17:59:02
permalink: /pages/01faeb/
categories:
  - 极客时间
  - 实用密码学
tags:
  - 
---
<audio title="15.AEAD有哪些安全陷阱？" src="https://static001.geekbang.org/resource/audio/f4/ca/f42251b0d84107f8a8f265cdf5940aca.mp3" controls="controls"></audio> 
<p>你好，我是范学雷。</p><p>上一讲，我们讨论了加密数据如何才能够自我验证，自我验证就是指解密的时候，还能够同时检验数据的完整性。我们还谈到了带关联数据的认证加密（AEAD）是目前市场的主流思路。</p><p>我们有了带关联的认证加密算法，应用程序再也不需要自行设计、解决数据的完整性问题了。但问题是，如果我们要在应用程序中使用带关联数据的认证加密，有哪些算法可以使用？</p><p>带关联数据的认证加密算法，有没有需要小心的安全陷阱？这是我们这一次需要解决的问题。</p><h2>有哪些常见的算法？</h2><p>还是老规矩，我们先来看看有哪些常见的算法。现在，常见的AEAD模式有三种：</p><ul>
<li>GCM；</li>
<li>CCM；</li>
<li>Poly1305。</li>
</ul><p>一般地，我们可以把带关联数据的认证加密看做一个加密模式，就像CBC模式一样，我们可以和前面提到的AES等加密算法进行组合。但ChaCha20和Poly1305通常组合在一起；Camellia与AES通常和GCM以及CCM组合在一起。</p><p>由于AEAD模式相对较新，而3DES/DES等遗留或者退役算法又存在明显的安全缺陷，所以，我们一般不会使用遗留或者退役算法的AEAD模式。</p><p>如果我们重新整理一下，综合考虑加密算法和加密模式，那么，当前推荐使用的、有广泛支持的、风险最小的算法是：</p><!-- [[[read_end]]] --><ul>
<li>AES/GCM；</li>
<li>ChaCha20/Poly1305；</li>
<li>AES/CCM。</li>
</ul><p>如果你的应用程序使用上述三个算法里的任何一个，就可以规避掉我们前面讨论的很多风险。经过了十多次的讨论，不知道你有没有变得小心谨慎？<strong>我们在使用任何算法之前，都要先存疑，后求证</strong>。这时候，你应该要问了，那这三个算法有没有风险？</p><h2>AEAD有风险吗？</h2><p>还记得吗？我们上面提到的AEAD算法，都需要使用初始化向量。虽然ChaCha20/Poly1305不属于分组密码的分类，但是这个算法也需要使用初始化向量。</p><p>我们前面特意讨论过初始化向量选择的一个原则：<strong>在一个对称密钥的生命周期里，初始化向量不能重复</strong>。所以，对于AES/GCM算法，同样的对称密钥，一定不要使用重复的初始化向量。否则的话，就存在安全漏洞。</p><p>你发现了，<strong>初始化向量的重复问题，<strong><strong>就</strong></strong>是使用AEAD算法的最大风险，也是最难处理的风险</strong>。没有密码学经验的开发者可能会忽视这个风险，相应的应用程序也可能因此存在严重的安全问题。</p><p>在前面讨论分组对称密码的时候，我们讨论过两个初始化向量选择的方案：使用随机数以及使用序列数。然而，这两个方案也是各有各的缺陷。</p><h2>单相思的随机数</h2><p>我们先来看看，使用随机数作为初始化向量有什么问题呢？</p><p>谈到使用随机数作为初始化向量，我们指的是信息发送方的行为。既然信息的发送方使用的是随机数，信息的接收方怎么能知道这个随机数的数据呢？</p><p>不使用同样的初始化向量，信息接收方是没有办法解密加密数据的。<strong>该怎么解决初始化向量在信息发送方和接收方之间的同步问题？这是使用随机数作为初始化向量必须要考虑清楚的问题。</strong></p><p>幸运的是，对于上述我们提到的AEAD算法，初始化向量并不需要保密。一个常用的方案，信息发送方发送加密信息的时候，可以把明文的初始化向量一起发送。信息接收方直接使用接收到的明文初始化向量，就可以解密加密数据了。</p><p>不过，随之而来的问题是，如果有攻击者修改了明文传递的初始化向量，信息接收方能够察觉吗？这个答案是肯定的。不同于没有验证的加密算法，AEAD有自我验证的能力，如果初始化向量被篡改，解密过程中，数据验证这一关是通不过去的。</p><p>也就是说，解密不会成功，篡改可以被检测出来。</p><p>还有一个问题，我们需要注意随机数的大小。对于这个问题，我们要再次考虑初始化向量选择的原则，<strong>在一个对称密钥的生命周期里，初始化向量不能重复。</strong>也就是说，随机数必须有足够的容量，使得在对称密钥的生命周期里，都不太可能出现重复的随机数。</p><p>最常用的经验数据，是使用64位的随机数。64位的初始化向量，支持2^64的加密运算。大部分的应用程序都难以达到这么大的运算量。</p><p>不过，需要注意的是，虽然随机数的文字里带有数字，我们也不能把随机数看做是整数。在密码学的范畴里，随机数指的是随机的数据，不是随机的数字。</p><p>所以，千万不要移除随机数头尾的零，要保持随机数完整的位数。64位的随机数，就一定要有64位的数据。即使头尾可能是零，也不能掐头去尾变成63位或62位，或者画蛇添足变成65位。</p><p>使用随机数作为初始化向量，还有一个常被忽视的小缺陷。随机数的初始化通常是一个费时费力的过程。在应用程序里，大量的随机数实例的初始化可能会造成应用程序的性能问题，甚至包括应用程序的停顿。</p><p>不过，对于有经验的程序员来说，这是一个好解决的问题。只要选择好随机数发生器、减少随机数实例数就可以了。具体的情况，我们后面再讨论。</p><p>除此之外，使用随机数作为初始化向量，还有一个小小的缺陷，就是需要额外传递初始化向量。不过，对于大部分应用来说，这点小缺陷，并不是什么问题。</p><h2>难断舍的序列数</h2><p>在部分场景中，随机数的产生是一个费时费力的过程。但是，对于AEAD算法，只要初始化向量不重复就行，并不要求初始化向量不可预测。避免昂贵的随机数，是我们在使用密码学技术时，要经常考虑的问题。<strong>使用序列数作为初始化向量，就是一个最流行的方案。</strong></p><p>如果使用序列数，你需要注意的是，使用静态的对称密钥，特别需要注意序列数的静态化。比如说，对称密钥存在磁盘上，每次启动程序，都加载该密钥。那么，如果序列数没有对应的保存下来，每次启动的应用程序就有可能使用重复的序列数，从而带来严重的安全问题。</p><p>如果序列数也保存在磁盘上，并且每次程序启动时，加载密钥的时候，也加载序列数，我们也需要注意多线程的同步问题，其实也不省心。</p><p>使用静态的对称密钥的问题很多，我们后面还要讨论其他的安全问题。根本的办法，就是避免使用静态的密码。对称密钥，最好使用的时候再生成它，使用完立即销毁，不保存，不长期使用（不超过7天）。</p><p>理想地，如果信息发送方的每一个信息，信息接收方都能够收到，中间没有攻击者的干扰，使用序列数的初始化向量就不需要传递。信息发送方和接收方各自独立维护一个序列数计数器，就可以保持初始化向量的同步问题了。</p><p>但是，这种状况太理想了，有很强的局限性，只能在严格的、没有序列数错配的场景使用。</p><p>在网络环境中，信息可能丢失，或者被丢失，或者被攻击者插入攻击信息，或者被攻击者丢弃部分数据，这些都会引起序列数的错配问题，打乱信息接收方的节奏，错乱信息接收方的计数器。</p><p>怎么能够获得序列数开销小的好处，同时避免序列数错配的问题呢？</p><ul>
<li>序列数的开销小，直接受益方是信息发送方；</li>
<li>序列数错配，直接受害方是信息接受者。</li>
</ul><p>如果信息接收方不需要保持序列数的状态，不需要匹配序列数，也就没有序列数错配的烦恼了。</p><p>其实，答案也很明显。信息发送方可以像使用随机数初始化向量一样，发送加密信息的时候，把明文的初始化向量（也就是序列数）一起发送。信息接收方直接使用接收到的明文初始化向量，而不用理会这个初始化向量是一个随机数，还是一个序列数，或者是其他的什么数据。</p><p><strong>传送明文的序列数这一个方案，兼顾了信息发送方的效率，规避了信息接收方的顾虑，是目前最常用的初始化向量选择方案</strong>。</p><p>不过，还是要说一点注意的，既然信息接收方不再需要判别接收到初始化向量是一个随机数还是一个序列数，信息发送方就要兼顾到信息接收方的处理便利。</p><p>即使序列数是1，也要按照固定的位数传输，比如我们前面讨论过的固定的64位数据。如果序列数较小，可以前面补零，直到满足64位的数据要求。</p><p>到目前为止，我们已经知道了，新的应用程序里，应该优先使用AEAD算法。AEAD算法需要初始化向量，明文信息，关联信息，还有密钥。</p><p>你有没有想过这样的问题：密钥从哪里来的？密钥应该是什么样的？回答这些问题之前，我们要先讨论一个对称密钥依赖的技术，随机数。我们下次聊聊随机数以及随机数发生器。</p><h2>Take Away（今日收获）</h2><p>今天，我们讨论了常见的带关联数据的认证加密算法，以及使用带关联数据的认证加密算法的常见问题，也就是初始化向量的问题。</p><p>我们还列出了当前推荐使用的、有广泛支持的、风险最小的算法。它们是：</p><ul>
<li>AES/GCM；</li>
<li>ChaCha20/Poly1305；</li>
<li>AES/CCM。</li>
</ul><p>通过今天的讨论，我们要：</p><ul>
<li>知道常用的三个AEAD算法；</li>
<li>知道AEAD算法初始化向量不能重复的要求；</li>
<li>知道AEAD算法常用的初始化向量选择方案。</li>
</ul><h2>思考题</h2><p>今天的思考题，是一个需要动手的题。</p><p>在不同的章节，我们花了很大的精力来讨论初始化向量的问题。这是一个特别容易忽视的环节。</p><p>在你正在开发的项目中，或者你关注的开放源代码项目中，试着搜索、统计一下初始化向量的使用状况。加密端有没有使用重复的初始化向量？解密端有没有办法检验初始化向量的重复？初始化向量选择的是随机数还是序列数，或者随机数和序列数的组合？</p><p>你有没有发现不恰当的初始化向量使用方案？</p><p>欢迎在留言区留言，记录、讨论你的发现。</p><p>好的，今天就这样，我们下次再聊。</p>